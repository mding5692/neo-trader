/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var phosphor_domutil_1 = require('phosphor-domutil');
/**
 * The class name added to drag image nodes.
 */
var DRAG_IMAGE_CLASS = 'p-mod-drag-image';
/**
 * An enum which defines the possible independent drop actions.
 */
(function (DropAction) {
    /**
     * No item may be dropped.
     */
    DropAction[DropAction["None"] = 0] = "None";
    /**
     * The item is copied into its new location.
     */
    DropAction[DropAction["Copy"] = 1] = "Copy";
    /**
     * The item is linked to its new location.
     */
    DropAction[DropAction["Link"] = 2] = "Link";
    /**
     * The item is moved to its new location.
     */
    DropAction[DropAction["Move"] = 4] = "Move";
})(exports.DropAction || (exports.DropAction = {}));
var DropAction = exports.DropAction;
/**
 * An enum which defines the combinations of possible drop actions.
 */
(function (DropActions) {
    /**
     * No drop action is supported.
     */
    DropActions[DropActions["None"] = 0] = "None";
    /**
     * The item may be copied to its new location.
     */
    DropActions[DropActions["Copy"] = 1] = "Copy";
    /**
     * The item may be linked to its new location.
     */
    DropActions[DropActions["Link"] = 2] = "Link";
    /**
     * The item may be moved to its new location.
     */
    DropActions[DropActions["Move"] = 4] = "Move";
    /**
     * The item may be copied or linked to its new location.
     */
    DropActions[DropActions["CopyLink"] = 3] = "CopyLink";
    /**
     * The item may be copied or moved to its new location.
     */
    DropActions[DropActions["CopyMove"] = 5] = "CopyMove";
    /**
     * The item may be linked or moved to its new location.
     */
    DropActions[DropActions["LinkMove"] = 6] = "LinkMove";
    /**
     * The item may be copied, linked, or moved to its new location.
     */
    DropActions[DropActions["All"] = 7] = "All";
})(exports.DropActions || (exports.DropActions = {}));
var DropActions = exports.DropActions;
/**
 * An object which stores MIME data for drag-drop operations.
 *
 * #### Notes
 * This class does not attempt to enforce "correctness" of MIME types
 * and their associated data. Since this drag-drop system is designed
 * to transfer arbitrary data and objects within the same application,
 * it assumes that the user provides correct and accurate data.
 */
var MimeData = (function () {
    function MimeData() {
        this._types = [];
        this._values = [];
    }
    /**
     * Get an array of the MIME types contains within the dataset.
     *
     * @returns A new array of the MIME types, in order of insertion.
     */
    MimeData.prototype.types = function () {
        return this._types.slice();
    };
    /**
     * Test whether the dataset has an entry for the given type.
     *
     * @param mime - The MIME type of interest.
     *
     * @returns `true` if the dataset contains a value for the given
     *   MIME type, `false` otherwise.
     */
    MimeData.prototype.hasData = function (mime) {
        return this._types.indexOf(mime) !== -1;
    };
    /**
     * Get the data value for the given MIME type.
     *
     * @param mime - The MIME type of interest.
     *
     * @returns The value for the given MIME type, or `undefined` if
     *   the dataset does not contain a value for the type.
     */
    MimeData.prototype.getData = function (mime) {
        var i = this._types.indexOf(mime);
        return i !== -1 ? this._values[i] : void 0;
    };
    /**
     * Set the data value for the given MIME type.
     *
     * @param mime - The MIME type of interest.
     *
     * @param data - The data value for the given MIME type.
     *
     * #### Notes
     * This will overwrite any previous entry for the MIME type.
     */
    MimeData.prototype.setData = function (mime, data) {
        this.clearData(mime);
        this._types.push(mime);
        this._values.push(data);
    };
    /**
     * Remove the data entry for the given MIME type.
     *
     * @param mime - The MIME type of interest.
     *
     * #### Notes
     * This is a no-op if there is no entry for the given MIME type.
     */
    MimeData.prototype.clearData = function (mime) {
        var i = this._types.indexOf(mime);
        if (i === -1)
            return;
        this._types.splice(i, 1);
        this._values.splice(i, 1);
    };
    /**
     * Remove all data entries from the dataset.
     */
    MimeData.prototype.clear = function () {
        this._types.length = 0;
        this._values.length = 0;
    };
    return MimeData;
}());
exports.MimeData = MimeData;
/**
 * An object which manages a drag-drop operation.
 *
 * A drag object dispatches four different events to drop targets:
 *
 * - `'p-dragenter'` - Dispatched when the mouse enters the target
 *   element. This event must be canceled in order to receive any
 *   of the other events.
 *
 * - `'p-dragover'` - Dispatched when the mouse moves over the drop
 *   target. It must cancel the event and set the `dropAction` to one
 *   of the supported actions in order to receive drop events.
 *
 * - `'p-dragleave'` - Dispatched when the mouse leaves the target
 *   element. This includes moving the mouse into child elements.
 *
 * - `'p-drop'`- Dispatched when the mouse is released over the target
 *   element when the target indicates an appropriate drop action. If
 *   the event is canceled, the indicated drop action is returned to
 *   the initiator through the resolved promise.
 *
 * A drag operation can be canceled at any time by pressing `Escape`
 * or by disposing the drag object.
 *
 * #### Notes
 * This class is designed to be used when dragging and dropping custom
 * data *within* a single application. It is *not* a replacement for
 * the native drag-drop API. Instead, it provides an API which allows
 * drag operations to be initiated programmatically and enables the
 * transfer of arbitrary non-string objects; two features which are
 * not possible with the native drag-drop APIs.
 */
var Drag = (function () {
    /**
     * Construct a new drag object.
     *
     * @param options - The options for initializing the drag.
     */
    function Drag(options) {
        this._disposed = false;
        this._source = null;
        this._mimeData = null;
        this._dragImage = null;
        this._dropAction = DropAction.None;
        this._proposedAction = DropAction.Copy;
        this._supportedActions = DropActions.Copy;
        this._override = null;
        this._currentTarget = null;
        this._currentElement = null;
        this._promise = null;
        this._resolve = null;
        this._mimeData = options.mimeData;
        if (options.dragImage !== void 0) {
            this._dragImage = options.dragImage;
        }
        if (options.proposedAction !== void 0) {
            this._proposedAction = options.proposedAction;
        }
        if (options.supportedActions !== void 0) {
            this._supportedActions = options.supportedActions;
        }
        if (options.source !== void 0) {
            this._source = options.source;
        }
    }
    /**
     * Dispose of the resources held by the drag object.
     *
     * #### Notes
     * This will cancel the drag operation if it is active.
     *
     * All calls made after the first call to this method are a no-op.
     */
    Drag.prototype.dispose = function () {
        // Do nothing if the drag object is already disposed.
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        // If there is a current target, dispatch a drag leave event.
        if (this._currentTarget) {
            var event_1 = createMouseEvent('mouseup', -1, -1);
            dispatchDragLeave(this, this._currentTarget, null, event_1);
        }
        // Finalize the drag object with `None`.
        this._finalize(DropAction.None);
    };
    Object.defineProperty(Drag.prototype, "isDisposed", {
        /**
         * Test whether the drag object is disposed.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._disposed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Drag.prototype, "mimeData", {
        /**
         * Get the mime data for the drag object.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._mimeData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Drag.prototype, "dragImage", {
        /**
         * Get the drag image element for the drag object.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._dragImage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Drag.prototype, "proposedAction", {
        /**
         * Get the proposed drop action for the drag object.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._proposedAction;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Drag.prototype, "supportedActions", {
        /**
         * Get the supported drop actions for the drag object.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._supportedActions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Drag.prototype, "source", {
        /**
         * Get the drag source for the drag object.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._source;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start the drag operation at the specified client position.
     *
     * @param clientX - The client X position for the drag start.
     *
     * @param clientY - The client Y position for the drag start.
     *
     * @returns A promise which resolves to the result of the drag.
     *
     * #### Notes
     * If the drag has already been started, the promise created by the
     * first call to `start` is returned.
     *
     * If the drag operation has ended, or if the drag object has been
     * disposed, the returned promise will resolve to `DropAction.None`.
     *
     * The drag object will be automatically disposed when drag operation
     * completes. This makes `Drag` objects suitable for single use only.
     *
     * This method assumes the left mouse button is already held down.
     */
    Drag.prototype.start = function (clientX, clientY) {
        var _this = this;
        // If the drag object is already disposed, resolve to `None`.
        if (this._disposed) {
            return Promise.resolve(DropAction.None);
        }
        // If the drag has already been started, return the promise.
        if (this._promise) {
            return this._promise;
        }
        // Install the document listeners for the drag object.
        this._addListeners();
        // Attach the drag image at the specified client position.
        this._attachDragImage(clientX, clientY);
        // Create the promise which will be resolved on completion.
        this._promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
        });
        // Trigger a fake move event to kick off the drag operation.
        var event = createMouseEvent('mousemove', clientX, clientY);
        document.dispatchEvent(event);
        // Return the pending promise for the drag operation.
        return this._promise;
    };
    /**
     * Handle the DOM events for the drag operation.
     *
     * @param event - The DOM event sent to the drag object.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the document. It should not be
     * called directly by user code.
     */
    Drag.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            default:
                // Stop all other events during drag-drop.
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    /**
     * Handle the `'mousemove'` event for the drag object.
     */
    Drag.prototype._evtMouseMove = function (event) {
        // Stop all input events during drag-drop.
        event.preventDefault();
        event.stopPropagation();
        // Update the current target node and dispatch enter/leave events.
        this._updateCurrentTarget(event);
        // Move the drag image to the specified client position. This is
        // performed *after* dispatching to prevent unnecessary reflows.
        this._moveDragImage(event.clientX, event.clientY);
    };
    /**
     * Handle the `'mouseup'` event for the drag object.
     */
    Drag.prototype._evtMouseUp = function (event) {
        // Stop all input events during drag-drop.
        event.preventDefault();
        event.stopPropagation();
        // Do nothing if the left button is not released.
        if (event.button !== 0) {
            return;
        }
        // Update the current target node and dispatch enter/leave events.
        // This prevents a subtle issue where the DOM mutates under the
        // cursor after the last move event but before the drop event.
        this._updateCurrentTarget(event);
        // If there is no current target, finalize with `None`.
        if (!this._currentTarget) {
            this._finalize(DropAction.None);
            return;
        }
        // If the last drop action was `None`, dispatch a leave event
        // to the current target and finalize the drag with `None`.
        if (this._dropAction === DropAction.None) {
            dispatchDragLeave(this, this._currentTarget, null, event);
            this._finalize(DropAction.None);
            return;
        }
        // Dispatch the drop event at the current target and finalize
        // with the resulting drop action.
        var action = dispatchDrop(this, this._currentTarget, event);
        this._finalize(action);
    };
    /**
     * Handle the `'keydown'` event for the drag object.
     */
    Drag.prototype._evtKeyDown = function (event) {
        // Stop all input events during drag-drop.
        event.preventDefault();
        event.stopPropagation();
        // Cancel the drag if `Escape` is pressed.
        if (event.keyCode === 27)
            this.dispose();
    };
    /**
     * Add the document event listeners for the drag object.
     */
    Drag.prototype._addListeners = function () {
        document.addEventListener('mousedown', this, true);
        document.addEventListener('mousemove', this, true);
        document.addEventListener('mouseup', this, true);
        document.addEventListener('mouseenter', this, true);
        document.addEventListener('mouseleave', this, true);
        document.addEventListener('mouseover', this, true);
        document.addEventListener('mouseout', this, true);
        document.addEventListener('keydown', this, true);
        document.addEventListener('keyup', this, true);
        document.addEventListener('keypress', this, true);
        document.addEventListener('contextmenu', this, true);
    };
    /**
     * Remove the document event listeners for the drag object.
     */
    Drag.prototype._removeListeners = function () {
        document.removeEventListener('mousedown', this, true);
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('mouseenter', this, true);
        document.removeEventListener('mouseleave', this, true);
        document.removeEventListener('mouseover', this, true);
        document.removeEventListener('mouseout', this, true);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('keyup', this, true);
        document.removeEventListener('keypress', this, true);
        document.removeEventListener('contextmenu', this, true);
    };
    /**
     * Update the current target node using the given mouse event.
     */
    Drag.prototype._updateCurrentTarget = function (event) {
        // Fetch common local state.
        var prevTarget = this._currentTarget;
        var currTarget = this._currentTarget;
        var prevElem = this._currentElement;
        // Find the current indicated element at the given position.
        var currElem = document.elementFromPoint(event.clientX, event.clientY);
        // Update the current element reference.
        this._currentElement = currElem;
        // Note: drag enter fires *before* drag leave according to spec.
        // https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model
        // If the indicated element changes from the previous iteration,
        // and is different from the current target, dispatch the enter
        // events and compute the new target element.
        if (currElem !== prevElem && currElem !== currTarget) {
            currTarget = dispatchDragEnter(this, currElem, currTarget, event);
        }
        // If the current target element has changed, update the current
        // target reference and dispatch the leave event to the old target.
        if (currTarget !== prevTarget) {
            this._currentTarget = currTarget;
            dispatchDragLeave(this, prevTarget, currTarget, event);
        }
        // Dispatch the drag over event and update the drop action.
        var action = dispatchDragOver(this, currTarget, event);
        this._setDropAction(action);
    };
    /**
     * Attach the drag image element at the specified location.
     *
     * This is a no-op if there is no drag image element.
     */
    Drag.prototype._attachDragImage = function (clientX, clientY) {
        if (!this._dragImage) {
            return;
        }
        this._dragImage.classList.add(DRAG_IMAGE_CLASS);
        var style = this._dragImage.style;
        style.pointerEvents = 'none';
        style.position = 'absolute';
        style.top = clientY + "px";
        style.left = clientX + "px";
        document.body.appendChild(this._dragImage);
    };
    /**
     * Move the drag image element to the specified location.
     *
     * This is a no-op if there is no drag image element.
     */
    Drag.prototype._moveDragImage = function (clientX, clientY) {
        if (!this._dragImage) {
            return;
        }
        var style = this._dragImage.style;
        style.top = clientY + "px";
        style.left = clientX + "px";
    };
    /**
     * Detach the drag image element from the DOM.
     *
     * This is a no-op if there is no drag image element.
     */
    Drag.prototype._detachDragImage = function () {
        if (!this._dragImage) {
            return;
        }
        var parent = this._dragImage.parentNode;
        if (!parent) {
            return;
        }
        parent.removeChild(this._dragImage);
    };
    /**
     * Set the internal drop action state and update the drag cursor.
     */
    Drag.prototype._setDropAction = function (action) {
        if ((action & this._supportedActions) === 0) {
            action = DropAction.None;
        }
        if (this._override && this._dropAction === action) {
            return;
        }
        switch (action) {
            case DropAction.None:
                this._dropAction = action;
                this._override = phosphor_domutil_1.overrideCursor('no-drop');
                break;
            case DropAction.Copy:
                this._dropAction = action;
                this._override = phosphor_domutil_1.overrideCursor('copy');
                break;
            case DropAction.Link:
                this._dropAction = action;
                this._override = phosphor_domutil_1.overrideCursor('alias');
                break;
            case DropAction.Move:
                this._dropAction = action;
                this._override = phosphor_domutil_1.overrideCursor('move');
                break;
        }
    };
    /**
     * Finalize the drag operation and resolve the drag promise.
     */
    Drag.prototype._finalize = function (action) {
        // Store the resolve function as a temp variable.
        var resolve = this._resolve;
        // Remove the document event listeners.
        this._removeListeners();
        // Detach the drag image.
        this._detachDragImage();
        // Dispose of the cursor override.
        if (this._override)
            this._override.dispose();
        // Clear the mime data.
        if (this._mimeData)
            this._mimeData.clear();
        // Clear the internal drag state.
        this._disposed = true;
        this._source = null;
        this._mimeData = null;
        this._dragImage = null;
        this._dropAction = DropAction.None;
        this._proposedAction = DropAction.None;
        this._supportedActions = DropActions.None;
        this._override = null;
        this._currentTarget = null;
        this._currentElement = null;
        this._promise = null;
        this._resolve = null;
        // Resolve the promise to the given drop action, if possible.
        if (resolve)
            resolve(action);
    };
    return Drag;
}());
exports.Drag = Drag;
/**
 * Create a left mouse event at the given position.
 *
 * @param type - The event type for the mouse event.
 *
 * @param clientX - The client X position.
 *
 * @param clientY - The client Y position.
 *
 * @returns A newly created and initialized mouse event.
 */
function createMouseEvent(type, clientX, clientY) {
    var event = document.createEvent('MouseEvent');
    event.initMouseEvent(type, true, true, window, 0, 0, 0, clientX, clientY, false, false, false, false, 0, null);
    return event;
}
/**
 * Create a new initialized `IDragEvent` from the given data.
 *
 * @param type - The event type for the drag event.
 *
 * @param drag - The drag object to use for seeding the drag data.
 *
 * @param event - The mouse event to use for seeding the mouse data.
 *
 * @param related - The related target for the event, or `null`.
 *
 * @returns A new object which implements `IDragEvent`.
 */
function createDragEvent(type, drag, event, related) {
    // Create a new mouse event and cast to a custom drag event.
    var dragEvent = document.createEvent('MouseEvent');
    // Initialize the mouse event data.
    dragEvent.initMouseEvent(type, true, true, window, 0, event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, related);
    // Add the custom drag event data.
    dragEvent.mimeData = drag.mimeData;
    dragEvent.dropAction = DropAction.None;
    dragEvent.proposedAction = drag.proposedAction;
    dragEvent.supportedActions = drag.supportedActions;
    dragEvent.source = drag.source;
    // Return the fully initialized drag event.
    return dragEvent;
}
/**
 * Dispatch a drag enter event to the indicated element.
 *
 * @param drag - The drag object associated with the action.
 *
 * @param currElem - The currently indicated element, or `null`. This
 *   is the "immediate user selection" from the whatwg spec.
 *
 * @param currTarget - The current drag target element, or `null`. This
 *   is the "current target element" from the whatwg spec.
 *
 * @param event - The mouse event related to the action.
 *
 * @returns The element to use as the current drag target. This is the
 *   "current target element" from the whatwg spec, and may be `null`.
 *
 * #### Notes
 * This largely implements the drag enter portion of the whatwg spec:
 * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model
 */
function dispatchDragEnter(drag, currElem, currTarget, event) {
    // If the current element is null, return null as the new target.
    if (!currElem) {
        return null;
    }
    // Dispatch a drag enter event to the current element.
    var dragEvent = createDragEvent('p-dragenter', drag, event, currTarget);
    var canceled = !currElem.dispatchEvent(dragEvent);
    // If the event was canceled, use the current element as the new target.
    if (canceled) {
        return currElem;
    }
    // If the current element is the document body, keep the original target.
    if (currElem === document.body) {
        return currTarget;
    }
    // Dispatch a drag enter event on the document body.
    dragEvent = createDragEvent('p-dragenter', drag, event, currTarget);
    document.body.dispatchEvent(dragEvent);
    // Ignore the event cancellation, and use the body as the new target.
    return document.body;
}
/**
 * Dispatch a drag leave event to the indicated element.
 *
 * @param drag - The drag object associated with the action.
 *
 * @param prevTarget - The previous target element, or `null`. This
 *   is the previous "current target element" from the whatwg spec.
 *
 * @param currTarget - The current drag target element, or `null`. This
 *   is the "current target element" from the whatwg spec.
 *
 * @param event - The mouse event related to the action.
 *
 * #### Notes
 * This largely implements the drag leave portion of the whatwg spec:
 * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model
 */
function dispatchDragLeave(drag, prevTarget, currTarget, event) {
    // If the previous target is null, do nothing.
    if (!prevTarget) {
        return;
    }
    // Dispatch the drag leave event to the previous target.
    var dragEvent = createDragEvent('p-dragleave', drag, event, currTarget);
    prevTarget.dispatchEvent(dragEvent);
}
/**
 * Dispatch a drag over event to the indicated element.
 *
 * @param drag - The drag object associated with the action.
 *
 * @param currTarget - The current drag target element, or `null`. This
 *   is the "current target element" from the whatwg spec.
 *
 * @param event - The mouse event related to the action.
 *
 * @returns The `DropAction` result of the drag over event.
 *
 * #### Notes
 * This largely implements the drag over portion of the whatwg spec:
 * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model
 */
function dispatchDragOver(drag, currTarget, event) {
    // If there is no current target, the drop action is none.
    if (!currTarget) {
        return DropAction.None;
    }
    // Dispatch the drag over event to the current target.
    var dragEvent = createDragEvent('p-dragover', drag, event, null);
    var canceled = !currTarget.dispatchEvent(dragEvent);
    // If the event was canceled, return the drop action result.
    if (canceled) {
        return dragEvent.dropAction;
    }
    // Otherwise, the effective drop action is none.
    return DropAction.None;
}
/**
 * Dispatch a drop event to the indicated element.
 *
 * @param drag - The drag object associated with the action.
 *
 * @param currTarget - The current drag target element, or `null`. This
 *   is the "current target element" from the whatwg spec.
 *
 * @param event - The mouse event related to the action.
 *
 * @returns The `DropAction` result of the drop event.
 *
 * #### Notes
 * This largely implements the drag over portion of the whatwg spec:
 * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model
 */
function dispatchDrop(drag, currTarget, event) {
    // If there is no current target, the drop action is none.
    if (!currTarget) {
        return DropAction.None;
    }
    // Dispatch the drop event to the current target.
    var dragEvent = createDragEvent('p-drop', drag, event, null);
    var canceled = !currTarget.dispatchEvent(dragEvent);
    // If the event was canceled, return the drop action result.
    if (canceled) {
        return dragEvent.dropAction;
    }
    // Otherwise, the effective drop action is none.
    return DropAction.None;
}
